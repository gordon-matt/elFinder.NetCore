using elFinder.NetCore.Drawing;
using elFinder.NetCore.Drivers;
using elFinder.NetCore.Http;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;

namespace elFinder.NetCore
{
	/// <summary>
	/// Represents a root of file system
	/// </summary>
	public class RootVolume
    {
        public RootVolume(string rootDirectory, string url, string thumbnailsUrl = null)
        {
            if (rootDirectory == null)
            {
                throw new ArgumentNullException("rootDirectory", "Root directory cannot be null");
            }

            Alias = Path.GetFileNameWithoutExtension(rootDirectory);
            RootDirectory = rootDirectory;
            Url = url;
            UploadOverwrite = true;
            ThumbnailSize = 48;
            PictureEditor = new DefaultPictureEditor();

            // https://github.com/EvgenNoskov/Elfinder.NET/blob/fb19f17a3682ed81cadcfea978dcce575806eebd/docs/Documentation.md
            if (!string.IsNullOrEmpty(thumbnailsUrl))
            {
                ThumbnailUrl = thumbnailsUrl;
            }

			// Use '/' as a universal way to separate paths. FileSystem operations allow it and using '\\' breaks AzureStorage and other connectors in the future.
			// If necessary, we can add this to IDirectory and make it connector specific.
			ThumbnailDirectory = string.Concat(rootDirectory, "/", ".tmb");
        }

        /// <summary>
        /// Get or sets alias for root. If not set will use directory name of path
        /// </summary>
        public string Alias { get; set; }

        /// <summary>
        /// Get or sets if root is locked (user can't remove, rename or delete files or subdirectories)
        /// </summary>
        public bool IsLocked { get; }

        /// <summary>
        /// Get or sets if root for read only (users can't change file)
        /// </summary>
        public bool IsReadOnly { get; set; }

        /// <summary>
        /// Get or sets if user can only show files (and cannot download).
        /// Note: if you set url property, than users can access to directory by the provided url
        /// </summary>
        public bool IsShowOnly { get; }

        /// <summary>
        /// Gets or sets a list of root subfolders that should be locked (user can't remove, rename)
        /// </summary>
        public List<string> LockedFolders { get; }

        /// <summary>
        /// Get or sets maximum upload file size. This size is per files in bytes.
        /// Note: you still to configure maxupload limits in web.config for whole application
        /// </summary>
        public int? MaxUploadSize { get; set; }

        /// <summary>
        /// Get or sets maximum upload file size. This size is per files in kb.
        /// Note: you still to configure maxupload limits in web.config for whole application
        /// </summary>
        public double? MaxUploadSizeInKb
        {
            get { return MaxUploadSize.HasValue ? (double?)(MaxUploadSize.Value / 1024.0) : null; }
            set { MaxUploadSize = value.HasValue ? (int?)(value * 1024) : null; }
        }

        /// <summary>
        /// Get or sets maximum upload file size. This size is per files in Mb.
        /// Note: you still to configure maxupload limits in web.config for whole application
        /// </summary>
        public double? MaxUploadSizeInMb
        {
            get { return MaxUploadSizeInKb.HasValue ? (double?)(MaxUploadSizeInKb.Value / 1024.0) : null; }
            set { MaxUploadSizeInKb = value.HasValue ? (int?)(value * 1024) : null; }
        }

        /// <summary>
        /// Gets the picture editor for this volume
        /// </summary>
        public IPictureEditor PictureEditor { get; }

        /// <summary>
        /// Get or sets a directory which is root
        /// </summary>
        public string RootDirectory { get; }

        /// <summary>
        /// Get or sets a subfolder of root diretory, which will be start
        /// </summary>
        public string StartDirectory { get; }

        /// <summary>
        /// Get ot sets thumbnals directory
        /// </summary>
        public string ThumbnailDirectory { get; }

        /// <summary>
        /// Get or sets thumbnails size
        /// </summary>
        public int ThumbnailSize { get; }

        /// <summary>
        /// Get ot sets thumbnails url
        /// </summary>
        public string ThumbnailUrl { get; }

        /// <summary>
        /// Get or sets if files on upload will replace or give them new names. true - replace old files, false give new names like original_name-number.ext
        /// </summary>
        public bool UploadOverwrite { get; }

        /// <summary>
        /// Get or sets url that points to path directory (also called 'root URL').
        /// </summary>
        public string Url { get; }

        /// <summary>
        /// Gets a autogenerated prefix of root
        /// </summary>
        public string VolumeId { get; set; }

        public bool CanCreateThumbnail(IFile input)
        {
            return ThumbnailUrl != null && PictureEditor.CanProcessFile(input.Extension);
        }

        public async Task<string> GenerateThumbHashAsync(IFile originalImage)
        {
            if (ThumbnailDirectory == null)
            {
                string thumbName = Path.GetFileNameWithoutExtension(originalImage.Name) + "_" + await Cryptography.GetFileMd5Async(originalImage) + originalImage.Extension;
                string relativePath = originalImage.DirectoryName.Substring(RootDirectory.Length);
                return VolumeId + HttpEncoder.EncodePath($"{relativePath}/{thumbName}");
            }
            else
            {
                string thumbPath = await GenerateThumbPathAsync(originalImage);
                string relativePath = thumbPath.Substring(ThumbnailDirectory.Length);
                return VolumeId + HttpEncoder.EncodePath(relativePath);
            }
        }

        public async Task<string> GenerateThumbPathAsync(IFile originalImage)
        {
            if (ThumbnailDirectory == null || !CanCreateThumbnail(originalImage))
            {
                return null;
            }
            string relativePath = originalImage.FullName.Substring(RootDirectory.Length);
            string thumbDir = GetDirectoryName(string.Concat(ThumbnailDirectory + relativePath));
            string thumbName = Path.GetFileNameWithoutExtension(originalImage.Name) + "_" + await Cryptography.GetFileMd5Async(originalImage) + originalImage.Extension;
            return string.Concat(thumbDir, "/", thumbName);
        }

        public string GenerateThumbPath(IDirectory originalDirectory)
        {
            if (ThumbnailDirectory == null)
            {
                return null;
            }
            string relativePath = originalDirectory.FullName.Substring(RootDirectory.Length);
            return ThumbnailDirectory + relativePath;
        }

        private string GetDirectoryName(string file)
        {
            int length = file.Length;
            int startIndex = length;
            while (--startIndex >= 0)
            {
                char ch = file[startIndex];
                if (ch == '/' || ch == '\\')
                {
                    return file.Substring(0, startIndex);
                }
            }
            return string.Empty;
        }

        internal async Task<string> GetExistingThumbHashAsync(IFile originalImage)
        {
            string thumbPath = await GetExistingThumbPathAsync(originalImage);
            if (thumbPath == null)
            {
                return null;
            }
            string relativePath = thumbPath.Substring(ThumbnailDirectory.Length);
            return VolumeId + HttpEncoder.EncodePath(relativePath);
        }

        internal async Task<string> GetExistingThumbPathAsync(IFile originalImage)
        {
            string thumbPath = await GenerateThumbPathAsync(originalImage);
            return thumbPath;
        }

        internal string GetExistingThumbPath(IDirectory originalDirectory)
        {
            if (ThumbnailDirectory == null)
            {
                return null;
            }

            string relativePath = originalDirectory.FullName.Substring(RootDirectory.Length);
            string thumbDir = ThumbnailDirectory + relativePath;
            return thumbDir;
        }
    }
}